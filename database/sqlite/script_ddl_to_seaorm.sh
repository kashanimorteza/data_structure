#!/usr/bin/env bash
set -euo pipefail

# ====== CONFIG ======
DB_ENGIN="sqlite"                 # sqlite | mysql | postgres (only affects paths)
DB_NAME="db"                      # base name (no extension)
HCL_DIR="./${DB_ENGIN}"
OUT_DIR="./${DB_ENGIN}"
# ====================

HCL_IN="${HCL_DIR}/${DB_NAME}.hcl"
OUT_RS="${OUT_DIR}/${DB_NAME}.rs"


if [ ! -f "$HCL_IN" ]; then
  echo "❌ Input HCL file not found: $HCL_IN" >&2
  exit 1
fi

# --- 1) Convert HCL -> SQL (portable POSIX awk) ---
DDL_SQL="$(
/usr/bin/awk '
  function trim(s){sub(/^[[:space:]]+/,"",s); sub(/[[:space:]]+$/,"",s); return s}

  BEGIN{
    in_table=0; in_column=0; in_pk=0;
    columns_sql=""; pkey="";
    tname=""; colname=""; ctype=""; cnull="";
    ntables=0;
  }

  # Start of a table block:    table "name" {
  /^[[:space:]]*table[[:space:]]*"[^"]*"[[:space:]]*\{/ {
    # Extract table name without relying on fancy regex classes
    line=$0
    # capture between first pair of quotes after the word table
    if (match(line, /table[[:space:]]*"/)) {
      rest=substr(line, RSTART+RLENGTH)
      if (match(rest, /[^"]*/)) {
        tname=substr(rest, RSTART, RLENGTH)
        in_table=1; columns_sql=""; pkey="";
        ntables++; table_order[ntables]=tname;
      }
    }
    next;
  }

  # Start of a column block:   column "name" {
  in_table && /^[[:space:]]*column[[:space:]]*"[^"]*"[[:space:]]*\{/ {
    line=$0
    if (match(line, /column[[:space:]]*"/)) {
      rest=substr(line, RSTART+RLENGTH)
      if (match(rest, /[^"]*/)) {
        colname=substr(rest, RSTART, RLENGTH)
        ctype=""; cnull="";
        in_column=1;
      }
    }
    next;
  }

  # Column type = ...
  in_column && /[[:space:]]type[[:space:]]*=/ {
    line=$0
    sub(/.*type[[:space:]]*=[[:space:]]*/,"",line)
    line=trim(line)
    gsub(/[},]/,"",line)
    ctype=line         # keep as-is, supports varchar(7) or varchar
    next;
  }

  # Column null = true|false
  in_column && /[[:space:]]null[[:space:]]*=/ {
    line=$0
    sub(/.*null[[:space:]]*=[[:space:]]*/,"",line)
    line=trim(line)
    gsub(/[},]/,"",line)
    cnull=line         # "true" or "false"
    next;
  }

  # End of a column block:     }
  in_column && /^[[:space:]]*\}/ {
    type_out=ctype; gsub(/[[:space:]]+/,"",type_out)
    null_out = (cnull=="true" ? "NULL" : "NOT NULL")
    coldef = "  `" colname "` " type_out " " null_out
    if (columns_sql!="") columns_sql = columns_sql ",\n" coldef; else columns_sql=coldef
    in_column=0
    next;
  }

  # Primary key block start:   primary_key {
  in_table && /^[[:space:]]*primary_key[[:space:]]*\{/ { in_pk=1; next; }

  # Inside primary key:        columns = [column.id, column.other]
  in_pk && /columns[[:space:]]*=/ {
    line=$0
    if (match(line, /\[[^]]*\]/)) {
      inside=substr(line, RSTART+1, RLENGTH-2)
      # split by commas and spaces
      n=split(inside, arr, /[,[:space:]]+/)
      pkcols=""
      for (i=1;i<=n;i++) {
        if (match(arr[i], /column\.[A-Za-z0-9_]+/)) {
          cname=arr[i]
          sub(/^column\./, "", cname)
          if (cname!="") {
            if (pkcols!="") pkcols = pkcols ", "
            pkcols = pkcols "`" cname "`"
          }
        }
      }
      pkey=pkcols
    }
    next;
  }

  # End primary key block:     }
  in_pk && /^[[:space:]]*\}/ { in_pk=0; next; }

  # End of table block:        }
  in_table && /^[[:space:]]*\}/ {
    print "-- Create \"" tname "\" table"
    print "CREATE TABLE `" tname "` ("
    print columns_sql ","
    print "  PRIMARY KEY (" pkey ")"
    print ");"
    print ""
    in_table=0
    next;
  }
' "$HCL_IN"
)"

# --- 2) Extract table names (creation order) to build DROP list ---
read -r -d '' DROP_SQL <<EOF
$(
/usr/bin/awk '
  /^[[:space:]]*table[[:space:]]*"[^"]*"[[:space:]]*\{/ {
    line=$0
    if (match(line, /table[[:space:]]*"/)) {
      rest=substr(line, RSTART+RLENGTH)
      if (match(rest, /[^"]*/)) {
        names[++n]=substr(rest, RSTART, RLENGTH)
      }
    }
  }
  END{
    for (i=n;i>=1;i--) {
      printf "DROP TABLE IF EXISTS `%s`;\n", names[i]
    }
  }
' "$HCL_IN"
)
EOF

# Sanity check output
if ! printf "%s" "$DDL_SQL" | grep -q '^CREATE TABLE'; then
  echo "❌ Could not parse any tables from $HCL_IN" >&2
  exit 1
fi

# --- 3) Generate SeaORM migration (raw SQL) ---
cat > "$OUT_RS" <<'RUST'
// This file was generated by gen_from_hcl.sh (portable for macOS/BSD awk)
use sea_orm_migration::prelude::*;

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        // DDL generated from the HCL
        let sql: &str = r#"
RUST

printf "%s" "$DDL_SQL" >> "$OUT_RS"

cat >> "$OUT_RS" <<RUST
"#;
        manager.get_connection().execute_unprepared(sql).await?;
        Ok(())
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        let drop_sql: &str = r#"
RUST

printf "%s" "$DROP_SQL" >> "$OUT_RS"

cat >> "$OUT_RS" <<'RUST'
"#;
        manager.get_connection().execute_unprepared(drop_sql).await?;
        Ok(())
    }
}
RUST

echo "✅ Generated $OUT_RS from $HCL_IN"
